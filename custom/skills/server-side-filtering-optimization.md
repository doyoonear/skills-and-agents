# 대용량 상품 목록 서버 사이드 필터링 최적화 전략

10,000개 이상의 상품 목록에 대한 서버 사이드 필터링 UI 구현 시 적용할 수 있는 최적화 전략 가이드.

---

## 최적화 레이어 구조

```
┌─────────────────────────────────────────────────────────────────────┐
│  Layer 1: 입력 최적화                                                │
│  ┌───────────────────┬─────────────────┬─────────────────────────┐  │
│  │ 검색: Debounce    │ 체크박스: 즉시   │ 슬라이더: Debounce      │  │
│  └───────────────────┴─────────────────┴─────────────────────────┘  │
│                              ↓                                      │
│  Layer 2: 요청 최적화                                                │
│  ┌───────────────────────────┬───────────────────────────────────┐  │
│  │ AbortController           │ Request Deduplication             │  │
│  └───────────────────────────┴───────────────────────────────────┘  │
│                              ↓                                      │
│  Layer 3: 캐싱 최적화                                                │
│  ┌───────────────────────────┬───────────────────────────────────┐  │
│  │ staleTime / gcTime 설정   │ Prefetch 다음 페이지              │  │
│  └───────────────────────────┴───────────────────────────────────┘  │
│                              ↓                                      │
│  Layer 4: 렌더링 최적화                                              │
│  ┌─────────────┬──────────────┬──────────────┬─────────────────┐   │
│  │ React.memo  │ Skeleton UI  │ Image Lazy   │ Virtualization  │   │
│  └─────────────┴──────────────┴──────────────┴─────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Layer 1: 입력 최적화

### Debounce 전략 (입력 유형별 차등 적용)

| 입력 유형 | 전략 | 딜레이 | 이유 |
|----------|------|--------|------|
| 텍스트 검색 | Debounce | 300ms | 타이핑 완료 후 요청 |
| 체크박스 필터 | 즉시 반영 | 0ms | 명확한 사용자 의도 |
| 슬라이더/범위 | Debounce | 500ms | 드래그 중 요청 방지 |

### 핵심 원칙
- 사용자가 "입력 완료"했다고 판단되는 시점에 요청
- 체크박스처럼 명확한 액션은 즉시 반영
- 연속 입력(타이핑, 드래그)은 완료 후 반영

---

## Layer 2: 요청 최적화

### AbortController (Race Condition 방지)

**문제**: 빠르게 필터 변경 시 이전 응답이 나중에 도착 → UI 불일치

**해결**: 새 필터 적용 시 이전 요청 자동 취소
- TanStack Query: `queryFn`의 `signal` 파라미터 활용
- fetch API: `fetch(url, { signal })` 형태로 전달

### Request Deduplication

**문제**: 여러 컴포넌트에서 동일 데이터 요청 → 중복 네트워크 호출

**해결**:
- 동일한 queryKey에 대한 요청 자동 병합
- TanStack Query/SWR 등 데이터 페칭 라이브러리가 자동 처리

---

## Layer 3: 캐싱 최적화

### 캐시 설정 전략

| 설정 | 권장값 | 설명 |
|------|--------|------|
| staleTime | 30초 | fresh 상태 유지 시간 (이 시간 동안 refetch 안 함) |
| gcTime | 5분 | 캐시 보관 시간 (사용 안 해도 메모리에 유지) |
| refetchOnWindowFocus | false | 탭 포커스 시 자동 refetch 비활성화 |
| retry | 2 | 실패 시 재시도 횟수 |

### Query Key 설계

```typescript
// 필터 조합별로 별도 캐싱
queryKey: ['products', { search, categories, minPrice, maxPrice }]
```

- 같은 필터 조합으로 재방문 시 → 캐시 히트 → 즉시 표시
- 필터가 다르면 → 새 요청

### Prefetching 전략

**시점**: 현재 페이지 로드 완료 후
**대상**: 다음 페이지 데이터

**효과**: 스크롤 시 이미 캐시에 데이터 존재 → 즉시 표시

---

## Layer 4: 렌더링 최적화

### 컴포넌트 메모이제이션

**대상**: ProductCard 등 반복 렌더링되는 컴포넌트
**방법**: `React.memo()` 래핑
**효과**: props가 변경되지 않으면 리렌더 스킵

### 스켈레톤 UI (Perceived Performance)

**목적**:
- 로딩 중에도 레이아웃 유지 → CLS(Cumulative Layout Shift) 방지
- 사용자에게 "곧 콘텐츠가 표시될 것"이라는 기대감 제공

**적용 위치**:
- 초기 로딩 시: 전체 그리드 스켈레톤
- 추가 로딩 시: 하단 로딩 스피너

### 이미지 최적화

| 기법 | 설명 |
|------|------|
| Lazy Loading | 뷰포트 진입 시 로드 |
| Blur Placeholder | 로딩 중 블러 이미지 표시 |
| 적절한 크기 | 목록용 썸네일은 작은 사이즈로 |

### 가상화 (Virtualization)

**적용 조건**: 한 번에 수백 개 이상 렌더링해야 할 때
**일반적인 무한스크롤에서는 불필요**: 20개씩 로드하면 DOM 노드 관리 가능

---

## URL 동기화 전략

### Source of Truth 설계

```
URL (진실) → State (파생) → Data Fetching (결과)

┌─────────┐      ┌──────────┐      ┌─────────────┐
│   URL   │ ───▶ │  State   │ ───▶ │ React Query │
└─────────┘      └──────────┘      └─────────────┘
```

**원칙**: URL이 유일한 진실의 원천 (Single Source of Truth)

### Shallow Routing

**목적**: 페이지 리로드 없이 URL만 변경

**효과**:
- 페이지 컴포넌트 리렌더만 발생
- getServerSideProps/getStaticProps 재실행 안 함
- 빠른 필터 전환 UX

### 필터 직렬화 규칙

| 데이터 타입 | URL 표현 |
|------------|----------|
| 문자열 | `?search=키워드` |
| 배열 | `?categories=전자제품,과일` (콤마 구분) |
| 숫자 범위 | `?minPrice=10000&maxPrice=50000` |
| 빈 값 | 파라미터에서 제외 |

---

## API 설계 전략

### 커서 기반 vs 오프셋 기반 페이지네이션

| 방식 | 장점 | 단점 |
|------|------|------|
| **커서 기반** | 데이터 변경에 안정적, 일관된 결과 | 특정 페이지로 점프 어려움 |
| 오프셋 기반 | 구현 간단, 페이지 점프 가능 | 데이터 추가/삭제 시 중복/누락 |

**권장**: 무한스크롤에는 **커서 기반**

### 응답 데이터 최소화

**목록 API**: 표시에 필요한 필드만
```
id, name, price, discountPrice, image, category
```

**상세 API**: 전체 정보
```
+ description, specs, reviews, relatedProducts, ...
```

---

## UX 최적화 전략

### 로딩 상태 세분화

| 상태 | UI 표현 |
|------|---------|
| 초기 로딩 | 전체 스켈레톤 그리드 |
| 추가 로딩 (무한스크롤) | 하단 스피너 |
| 필터 변경 후 로딩 | 기존 데이터 유지 + 오버레이 or 스켈레톤 |

### Empty State 처리

**필수 요소**:
- "검색 결과가 없습니다" 메시지
- "필터 초기화" 버튼
- (선택) 유사 상품 추천

### 에러 처리

**필수 요소**:
- 에러 메시지
- "다시 시도" 버튼
- (선택) 자동 재시도 (retry 설정)

---

## 적용 시 고려사항

### 서버 사이드 필터링이 적합한 경우
- 데이터가 10,000개 이상
- 실시간 재고/가격 반영 필요
- 모바일 환경 지원 중요
- SEO 필요

### 클라이언트 사이드 필터링이 적합한 경우
- 데이터가 수천 개 이하
- 데이터 변경이 거의 없음
- 필터 즉각 반응이 매우 중요
- 오프라인 지원 필요

---

## 관련 기술 스택

| 목적 | 권장 도구 |
|------|----------|
| 상태 관리 | Zustand (가볍고 간결) |
| 데이터 페칭 | TanStack Query (캐싱, 무한스크롤 내장) |
| 가상화 | react-window, @tanstack/virtual |
| 이미지 최적화 | next/image (Next.js) |
