---
name: skill-creator
description: |
  Guide for creating effective skills.
  This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.
  한글 트리거: "스킬 만들어줘", "skill 만들어줘", "새 스킬 생성", "스킬 생성해줘", "스킬 제작" 등의 요청이 있을 때 사용.
  스킬을 ~/.claude/skills/ (전역) 또는 .claude/skills/ (프로젝트)에 생성.
license: Complete terms in LICENSE.txt
---

# 스킬 생성 가이드

Claude Code의 효과적인 스킬을 만드는 방법을 안내합니다.

## Step 0: 슬래시 커맨드 vs 스킬 선택

**무언가를 만들기 전에 적절한 유형을 결정하세요.** 슬래시 커맨드와 스킬은 서로 다른 목적을 가집니다.

### 비교표

| 구분 | 슬래시 커맨드 | 스킬 |
|------|----------------|--------|
| **파일 위치** | `.claude/commands/` 또는 `~/.claude/commands/` | `.claude/skills/name/` 또는 `~/.claude/skills/name/` |
| **파일 구조** | 단일 `.md` 파일 | 디렉토리 + `SKILL.md` + 추가 파일 |
| **호출 방식** | `/command` 명시적 입력 | Claude가 **자동으로** 발견 및 실행 |
| **Frontmatter** | **선택** (기능 추가 시 필요) | **필수** (`name`, `description`) |
| **복잡도** | 간단한 프롬프트 | 복잡한 다단계 워크플로우 |
| **추가 파일** | 불가능 (단일 파일만) | scripts/, references/, assets/ 가능 |

### 결정 플로우

```
사용자 요청 접수
    ↓
Q1: 사용자가 명시적으로 "/명령어"로 호출하길 원하는가?
    → Yes → 슬래시 커맨드
    → No ↓

Q2: Claude가 대화 내용 기반으로 자동 트리거해야 하는가?
    → Yes → 스킬
    → No ↓

Q3: 여러 파일(스크립트, 참조문서, 템플릿)이 필요한가?
    → Yes → 스킬
    → No ↓

Q4: 반복되는 간단한 프롬프트인가?
    → Yes → 슬래시 커맨드
    → No → 스킬 (복잡한 워크플로우)
```

### 슬래시 커맨드 적합 사례

- 자주 사용하는 간단한 프롬프트 (`/review`, `/explain`, `/optimize`)
- 단일 파일로 충분한 경우
- 사용자가 **명시적으로** 실행 시점을 제어하고 싶은 경우
- `$ARGUMENTS`로 사용자 입력만 받으면 되는 경우

**슬래시 커맨드 생성 예시:**

```markdown
<!-- ~/.claude/commands/review.md -->
이 코드를 리뷰해주세요.
$ARGUMENTS
```

```markdown
<!-- allowed-tools 사용 시 -->
---
allowed-tools: Read, Grep, Glob
---
이 코드를 리뷰해주세요.
```

### 스킬 적합 사례

- Claude가 **자동으로** 발견해야 할 복잡한 기능
- 여러 파일과 스크립트가 필요한 경우
- 팀 전체가 표준화된 워크플로우를 필요로 할 때
- 도메인 지식, 스키마, 비즈니스 로직이 포함된 경우

**⚠️ 스킬로 결정된 경우, 반드시 아래 가이드를 따라 SKILL.md에 frontmatter를 작성해야 합니다.**

---

## 스킬이란?

스킬은 Claude의 기능을 확장하는 모듈형, 독립형 패키지입니다. 특정 도메인이나 작업에 대한 "온보딩 가이드"로 생각하면 됩니다. 스킬은 Claude를 범용 에이전트에서 절차적 지식을 갖춘 전문 에이전트로 변환시킵니다.

### 스킬이 제공하는 것

1. **전문화된 워크플로우** - 특정 도메인의 다단계 절차
2. **도구 통합** - 특정 파일 형식이나 API 작업 방법
3. **도메인 전문성** - 회사 전용 지식, 스키마, 비즈니스 로직
4. **번들 리소스** - 복잡하고 반복적인 작업을 위한 스크립트, 참조 자료, 에셋

### 핵심 원칙

#### 1. 간결함이 핵심

컨텍스트 윈도우는 공공재입니다. 스킬은 시스템 프롬프트, 대화 기록, 다른 스킬의 메타데이터, 사용자 요청과 컨텍스트 윈도우를 공유합니다.

**기본 가정: Claude는 이미 매우 똑똑합니다.** Claude가 이미 알지 못하는 내용만 추가하세요. 각 정보에 대해 질문하세요: "Claude가 정말 이 설명이 필요한가?" 그리고 "이 문단이 토큰 비용을 정당화하는가?"

장황한 설명보다 간결한 예시를 선호하세요.

#### 2. 적절한 자유도 설정

작업의 취약성과 변동성에 맞는 구체성 수준을 선택하세요:

**높은 자유도 (텍스트 기반 지침)**: 여러 접근 방식이 유효하거나, 결정이 맥락에 따라 달라지거나, 휴리스틱이 접근 방식을 안내할 때 사용.

**중간 자유도 (의사코드 또는 매개변수가 있는 스크립트)**: 선호되는 패턴이 존재하거나, 일부 변형이 허용되거나, 구성이 동작에 영향을 미칠 때 사용.

**낮은 자유도 (특정 스크립트, 적은 매개변수)**: 작업이 취약하고 오류가 발생하기 쉽거나, 일관성이 중요하거나, 특정 순서를 따라야 할 때 사용.

Claude가 길을 탐색한다고 생각하세요: 절벽이 있는 좁은 다리는 특정 가드레일이 필요하지만(낮은 자유도), 열린 들판은 많은 경로를 허용합니다(높은 자유도).

### 스킬의 구조

모든 스킬은 필수 SKILL.md 파일과 선택적 번들 리소스로 구성됩니다:

```
skill-name/
├── SKILL.md (필수)
│   ├── YAML frontmatter 메타데이터 (⚠️ 필수)
│   │   ├── name: (필수) - 스킬 식별자
│   │   └── description: (필수) - 트리거 판단 기준
│   └── Markdown 본문 (필수)
└── 번들 리소스 (선택)
    ├── scripts/          - 실행 가능한 코드 (Python/Bash 등)
    ├── references/       - 필요시 컨텍스트에 로드될 문서
    └── assets/           - 출력에 사용될 파일 (템플릿, 아이콘, 폰트 등)
```

#### SKILL.md (필수)

모든 SKILL.md는 다음으로 구성됩니다:

- **Frontmatter** (YAML, ⚠️ **필수**): `name`과 `description` 필드 포함. **Claude는 오직 이 두 필드만 보고 스킬 사용 여부를 결정합니다.** 본문 내용은 트리거 판단에 사용되지 않습니다.
- **본문** (Markdown): 스킬 사용 가이드. 트리거 **후에만** 로드됩니다.

**⚠️ Frontmatter가 없으면 스킬이 인식되지 않습니다. 슬래시 커맨드와 달리 스킬에서는 필수입니다.**

#### 번들 리소스 (선택)

##### Scripts (`scripts/`)

결정론적 신뢰성이 필요하거나 반복적으로 작성되는 작업을 위한 실행 가능한 코드(Python/Bash 등).

- **포함 시기**: 동일한 코드가 반복적으로 작성되거나 결정론적 신뢰성이 필요할 때
- **예시**: PDF 회전 작업을 위한 `scripts/rotate_pdf.py`
- **장점**: 토큰 효율적, 결정론적, 컨텍스트에 로드하지 않고도 실행 가능
- **참고**: 스크립트는 패치나 환경별 조정을 위해 Claude가 읽어야 할 수도 있음

##### References (`references/`)

Claude의 프로세스와 사고를 안내하기 위해 필요시 컨텍스트에 로드될 문서 및 참조 자료.

- **포함 시기**: Claude가 작업 중 참조해야 할 문서가 있을 때
- **예시**: 금융 스키마를 위한 `references/finance.md`, 회사 NDA 템플릿을 위한 `references/mnda.md`, 회사 정책을 위한 `references/policies.md`, API 사양을 위한 `references/api_docs.md`
- **사용 사례**: 데이터베이스 스키마, API 문서, 도메인 지식, 회사 정책, 상세 워크플로우 가이드
- **장점**: SKILL.md를 간결하게 유지, Claude가 필요하다고 판단할 때만 로드됨
- **모범 사례**: 파일이 크면(>10k 단어) SKILL.md에 grep 검색 패턴 포함
- **중복 방지**: 정보는 SKILL.md 또는 references 파일 중 하나에만 존재해야 합니다. 상세 정보는 references 파일에 우선하여 SKILL.md를 간결하게 유지하세요. SKILL.md에는 필수 절차 지침과 워크플로우 가이드만 유지하고, 상세 참조 자료, 스키마, 예시는 references 파일로 이동하세요.

##### Assets (`assets/`)

컨텍스트에 로드되지 않고 Claude가 생성하는 출력에 사용될 파일.

- **포함 시기**: 스킬이 최종 출력에 사용될 파일이 필요할 때
- **예시**: 브랜드 에셋을 위한 `assets/logo.png`, PowerPoint 템플릿을 위한 `assets/slides.pptx`, HTML/React 보일러플레이트를 위한 `assets/frontend-template/`, 타이포그래피를 위한 `assets/font.ttf`
- **사용 사례**: 템플릿, 이미지, 아이콘, 보일러플레이트 코드, 폰트, 복사되거나 수정될 샘플 문서
- **장점**: 출력 리소스를 문서에서 분리, Claude가 컨텍스트에 로드하지 않고도 파일 사용 가능

#### 스킬에 포함하지 말아야 할 것

스킬은 기능을 직접 지원하는 필수 파일만 포함해야 합니다. 다음과 같은 불필요한 문서나 보조 파일을 만들지 마세요:

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 기타

스킬은 AI 에이전트가 작업을 수행하는 데 필요한 정보만 포함해야 합니다. 생성 과정, 설정 및 테스트 절차, 사용자 대상 문서 등 보조 컨텍스트를 포함하지 마세요. 추가 문서 파일을 만들면 혼란과 불필요한 복잡성만 증가합니다.

### 점진적 공개 원칙

스킬은 컨텍스트를 효율적으로 관리하기 위해 3단계 로딩 시스템을 사용합니다:

1. **메타데이터 (name + description)** - 항상 컨텍스트에 포함 (~100 단어)
2. **SKILL.md 본문** - 스킬 트리거 시 (<5k 단어)
3. **번들 리소스** - Claude가 필요시 (무제한, 스크립트는 컨텍스트 윈도우에 읽지 않고 실행 가능)

#### 점진적 공개 패턴

SKILL.md 본문을 필수 사항으로 유지하고 500줄 이하로 유지하여 컨텍스트 팽창을 최소화하세요. 이 한계에 도달하면 별도 파일로 분할하세요. 내용을 다른 파일로 분할할 때는 SKILL.md에서 참조하고 언제 읽어야 하는지 명확히 설명하여 스킬 독자가 존재를 알고 사용 시기를 이해하도록 하세요.

**핵심 원칙:** 스킬이 여러 변형, 프레임워크 또는 옵션을 지원하는 경우, SKILL.md에는 핵심 워크플로우와 선택 가이드만 유지하세요. 변형별 세부사항(패턴, 예시, 구성)은 별도 참조 파일로 이동하세요.

**패턴 1: 참조가 있는 상위 수준 가이드**

```markdown
# PDF 처리

## 빠른 시작

pdfplumber로 텍스트 추출:
[코드 예시]

## 고급 기능

- **양식 작성**: 전체 가이드는 [FORMS.md](FORMS.md) 참조
- **API 레퍼런스**: 모든 메서드는 [REFERENCE.md](REFERENCE.md) 참조
- **예시**: 일반적인 패턴은 [EXAMPLES.md](EXAMPLES.md) 참조
```

Claude는 필요시에만 FORMS.md, REFERENCE.md 또는 EXAMPLES.md를 로드합니다.

**패턴 2: 도메인별 구성**

여러 도메인을 가진 스킬의 경우, 관련 없는 컨텍스트 로딩을 피하기 위해 도메인별로 콘텐츠를 구성하세요:

```
bigquery-skill/
├── SKILL.md (개요 및 네비게이션)
└── reference/
    ├── finance.md (수익, 청구 지표)
    ├── sales.md (기회, 파이프라인)
    ├── product.md (API 사용, 기능)
    └── marketing.md (캠페인, 어트리뷰션)
```

사용자가 판매 지표에 대해 물으면 Claude는 sales.md만 읽습니다.

마찬가지로, 여러 프레임워크나 변형을 지원하는 스킬의 경우 변형별로 구성하세요:

```
cloud-deploy/
├── SKILL.md (워크플로우 + 제공자 선택)
└── references/
    ├── aws.md (AWS 배포 패턴)
    ├── gcp.md (GCP 배포 패턴)
    └── azure.md (Azure 배포 패턴)
```

사용자가 AWS를 선택하면 Claude는 aws.md만 읽습니다.

**패턴 3: 조건부 세부사항**

기본 내용을 표시하고 고급 내용은 링크로 연결:

```markdown
# DOCX 처리

## 문서 생성

새 문서는 docx-js 사용. [DOCX-JS.md](DOCX-JS.md) 참조.

## 문서 편집

간단한 편집은 XML을 직접 수정.

**변경 추적**: [REDLINING.md](REDLINING.md) 참조
**OOXML 세부사항**: [OOXML.md](OOXML.md) 참조
```

Claude는 사용자가 해당 기능이 필요할 때만 REDLINING.md 또는 OOXML.md를 읽습니다.

**중요 가이드라인:**

- **깊게 중첩된 참조 피하기** - SKILL.md에서 참조를 1단계 깊이로 유지. 모든 참조 파일은 SKILL.md에서 직접 링크되어야 함.
- **긴 참조 파일 구조화** - 100줄 이상인 파일의 경우, 상단에 목차를 포함하여 Claude가 미리보기할 때 전체 범위를 볼 수 있도록 함.

---

## 스킬 생성 워크플로우

사용자가 스킬 생성을 요청하면 다음 대화형 워크플로우를 따르세요:

### 1단계: 요구사항 수집

- 스킬의 목적과 기능에 대해 명확하고 구체적인 질문
- 적절한 경우 AskUserQuestion 도구 사용
- 모든 사양이 명확해질 때까지 계속 질문:
  * 스킬 이름 및 트리거 조건
  * 핵심 기능
  * 필요한 리소스 (scripts, references, assets)
  * 구체적인 예시가 있는 대상 사용 사례

이 단계는 스킬의 사용 패턴이 이미 명확히 이해된 경우에만 건너뛰세요. 기존 스킬 작업 시에도 유용합니다.

효과적인 스킬을 만들려면 스킬이 어떻게 사용될지 구체적인 예시를 명확히 이해해야 합니다. 이 이해는 사용자의 직접적인 예시나 사용자 피드백으로 검증된 생성 예시에서 나올 수 있습니다.

예를 들어, image-editor 스킬을 만들 때 관련 질문:

- "image-editor 스킬이 지원해야 할 기능은 무엇인가요? 편집, 회전, 그 외?"
- "이 스킬이 어떻게 사용될지 예시를 들어줄 수 있나요?"
- "'이 이미지에서 적목 현상 제거' 또는 '이 이미지 회전'과 같은 요청을 상상할 수 있습니다. 이 스킬이 사용될 다른 방법이 있나요?"
- "사용자가 무엇을 말했을 때 이 스킬이 트리거되어야 하나요?"

사용자를 압도하지 않도록 한 번에 너무 많은 질문을 하지 마세요. 가장 중요한 질문부터 시작하고 필요에 따라 후속 조치하세요.

스킬이 지원해야 할 기능에 대한 명확한 감각이 생기면 이 단계를 마무리하세요.

### 2단계: 계획 수립

구체적인 예시를 효과적인 스킬로 전환하려면 각 예시를 다음과 같이 분석하세요:

1. 예시를 처음부터 실행하는 방법 고려
2. 이러한 워크플로우를 반복적으로 실행할 때 도움이 될 scripts, references, assets 식별

**병렬 분석**: 대규모 코드베이스나 여러 디렉토리의 패턴을 분석할 때는 병렬 Explore 서브 에이전트를 사용하여 분석 속도를 높이세요. 자세한 내용은 references/workflows.md 참조.

예시: "이 PDF 회전해줘"와 같은 쿼리를 처리하기 위한 `pdf-editor` 스킬을 만들 때:

1. PDF 회전은 매번 동일한 코드를 다시 작성해야 함
2. `scripts/rotate_pdf.py` 스크립트가 스킬에 저장하면 도움이 됨

예시: "할 일 앱 만들어줘" 또는 "걸음 수를 추적하는 대시보드 만들어줘"와 같은 쿼리를 위한 `frontend-webapp-builder` 스킬을 설계할 때:

1. 프론트엔드 웹앱 작성은 매번 동일한 보일러플레이트 HTML/React가 필요함
2. 보일러플레이트 HTML/React 프로젝트 파일을 포함하는 `assets/hello-world/` 템플릿이 스킬에 저장하면 도움이 됨

예시: "오늘 로그인한 사용자는 몇 명인가요?"와 같은 쿼리를 처리하기 위한 `big-query` 스킬을 만들 때:

1. BigQuery 쿼리는 매번 테이블 스키마와 관계를 재발견해야 함
2. 테이블 스키마를 문서화한 `references/schema.md` 파일이 스킬에 저장하면 도움이 됨

스킬의 내용을 확립하려면 각 구체적인 예시를 분석하여 포함할 재사용 가능한 리소스 목록을 만드세요: scripts, references, assets.

상세한 계획을 작성하여 사용자에게 제시:
- 디렉토리 구조
- SKILL.md 개요
- scripts, references, assets 목록

### 3단계: 승인 대기

사용자가 명시적으로 승인할 때까지 구현을 진행하지 마세요.

### 4단계: 스킬 초기화

이 시점에서 실제로 스킬을 생성할 시간입니다.

개발 중인 스킬이 이미 존재하고 반복이나 패키징이 필요한 경우에만 이 단계를 건너뛰세요. 이 경우 다음 단계로 계속 진행하세요.

처음부터 새 스킬을 만들 때는 항상 `init_skill.py` 스크립트를 실행하세요. 이 스크립트는 스킬이 필요로 하는 모든 것을 자동으로 포함하는 새 템플릿 스킬 디렉토리를 편리하게 생성하여 스킬 생성 프로세스를 훨씬 효율적이고 안정적으로 만듭니다.

사용법:

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

스크립트는:

- 지정된 경로에 스킬 디렉토리 생성
- 적절한 frontmatter와 TODO 플레이스홀더가 있는 SKILL.md 템플릿 생성
- 예시 리소스 디렉토리 생성: `scripts/`, `references/`, `assets/`
- 각 디렉토리에 커스터마이즈하거나 삭제할 수 있는 예시 파일 추가

초기화 후 생성된 SKILL.md와 예시 파일을 필요에 따라 커스터마이즈하거나 제거하세요.

**스킬 위치**: `~/skills-and-agents/custom/skills/`

**중요**: 커스텀 스킬은 `custom/skills/`에 생성됩니다. `skill` 명령어로 설치되는 외부 스킬은 `external/skills/`에 자동 저장됩니다.

#### 전역 설정에 스킬 권한 등록

새 스킬을 만든 후 전역 settings.json에 등록하여 권한 프롬프트 없이 자동 실행을 허용하세요.

`~/.claude/settings.json`에 다음 추가:

```json
{
  "permissions": {
    "allow": [
      "Skill(/your-skill-name:*)"
    ]
  }
}
```

`pdf-editor`라는 스킬의 예시:

```json
"Skill(/pdf-editor:*)"
```

**권한 형식 규칙:**
- Skill: `Skill(/skill-name:*)` - 슬래시(`/`) 필수, `:*`는 인자용
- Bash: `Bash(command *)` - 공백 + `*` 와일드카드 (NOT `Bash(command:*)`)
- `Skill(*)`과 `Bash(*)` 전역 와일드카드는 지원되지 않음

### 5단계: 스킬 편집

(새로 생성되었거나 기존) 스킬을 편집할 때, 스킬이 다른 Claude 인스턴스가 사용하도록 만들어진다는 것을 기억하세요. Claude에게 유익하고 자명하지 않은 정보를 포함하세요. 다른 Claude 인스턴스가 이러한 작업을 더 효과적으로 수행하는 데 도움이 될 절차적 지식, 도메인별 세부사항 또는 재사용 가능한 에셋을 고려하세요.

#### 검증된 디자인 패턴 학습

스킬의 필요에 따라 다음 유용한 가이드를 참조하세요:

- **다단계 프로세스**: 순차 워크플로우, 조건부 로직, **서브 에이전트를 사용한 병렬 워크플로우**는 references/workflows.md 참조
- **특정 출력 형식 또는 품질 표준**: 템플릿 및 예시 패턴은 references/output-patterns.md 참조

이 파일들은 효과적인 스킬 디자인을 위한 확립된 모범 사례를 포함합니다.

#### 재사용 가능한 스킬 콘텐츠부터 시작

구현을 시작하려면 위에서 식별한 재사용 가능한 리소스부터 시작하세요: `scripts/`, `references/`, `assets/` 파일. 이 단계는 사용자 입력이 필요할 수 있습니다. 예를 들어, `brand-guidelines` 스킬을 구현할 때 사용자는 `assets/`에 저장할 브랜드 에셋이나 템플릿, 또는 `references/`에 저장할 문서를 제공해야 할 수 있습니다.

**병렬 리소스 생성**: 여러 독립적인 리소스(예: 여러 스크립트 또는 참조 파일)를 만들 때는 병렬 범용 서브 에이전트를 사용하여 동시에 생성하세요. 자세한 내용은 references/workflows.md 참조.

추가된 스크립트는 실제로 실행하여 테스트하여 버그가 없고 출력이 예상과 일치하는지 확인해야 합니다. 유사한 스크립트가 많은 경우, 모든 스크립트가 작동한다는 확신을 얻으면서 완료 시간의 균형을 맞추기 위해 대표 샘플만 테스트하면 됩니다.

스킬에 필요하지 않은 예시 파일과 디렉토리는 삭제해야 합니다. 초기화 스크립트는 구조를 보여주기 위해 `scripts/`, `references/`, `assets/`에 예시 파일을 생성하지만 대부분의 스킬은 모두 필요하지 않습니다.

#### SKILL.md 업데이트

**작성 가이드라인:** 항상 명령형/부정사 형식 사용.

##### Frontmatter (필수)

**⚠️ SKILL.md에는 반드시 YAML frontmatter가 있어야 합니다. frontmatter가 없으면 스킬이 작동하지 않습니다.**

```yaml
---
name: skill-name                    # 필수: 소문자, 숫자, 하이픈만 (최대 64자)
description: "무엇을 하고 언제 사용하는가"  # 필수: 최대 1024자
---
```

**필수 필드:**

- `name`: 스킬 이름 (소문자, 숫자, 하이픈만 허용)
- `description`: **Claude가 이 스킬을 언제 사용할지 판단하는 유일한 기준**
  - 본문 내용은 트리거 **후에만** 로드됨
  - "When to Use This Skill" 섹션을 본문에 넣어도 트리거 판단에 도움이 안 됨
  - 모든 트리거 조건과 키워드를 description에 포함해야 함
  - 예시: `"PDF 문서 편집, 회전, 병합, 분할 기능. 사용자가 'PDF 편집', 'PDF 회전', 'PDF 합치기' 등을 요청할 때 사용."`

**선택 필드:**

| 필드 | 설명 |
|------|------|
| `allowed-tools` | Skill 활성화 시 사용 가능한 도구 제한 |
| `model` | 특정 모델 지정 |
| `context: fork` | 독립된 sub-agent 컨텍스트에서 실행 |
| `user-invocable` | 슬래시 메뉴 표시 여부 (기본값: true) |

**⚠️ 위 필드 외에 다른 필드는 frontmatter에 넣지 마세요.**

**올바른 예시:**

```yaml
---
name: pdf-editor
description: |
  PDF 문서 편집, 회전, 병합, 분할, 텍스트 추출 기능.
  다음 요청 시 사용: "PDF 편집해줘", "PDF 회전", "PDF 합치기", "PDF 나누기", "PDF에서 텍스트 추출"
  한글 트리거: "PDF 편집", "피디에프 수정", "문서 회전" 등
---
```

##### 본문

스킬과 번들 리소스 사용을 위한 지침을 작성하세요.

### 6단계: 검증

모든 스킬은 요구사항을 충족하는지 검증해야 합니다:

```bash
scripts/package_skill.py <path/to/skill-folder>
```

스크립트는 두 가지 작업을 수행합니다:

1. **검증** (항상 수행):
   - YAML frontmatter 형식 및 필수 필드
   - 스킬 명명 규칙 및 디렉토리 구조
   - Description 완성도 및 품질
   - 파일 구성 및 리소스 참조

2. **패키징** (.skill 파일 생성):
   - 배포/공유용으로만 필요
   - 모든 파일을 포함한 `my-skill.skill` 생성
   - 검증 실패 시 자동으로 건너뜀

#### .skill 파일 이해하기

**.skill 파일은 배포 및 공유용입니다.** 로컬 사용에는 필요하지 않습니다.

**.skill 파일이 필요한 경우:**
- 다른 사람과 스킬 공유 (팀원, 마켓플레이스)
- 다운로드 가능한 패키지로 스킬 배포

**.skill 파일이 필요하지 않은 경우:**
- 개인/로컬 사용
- symlink를 통해 설치된 스킬 (`install.sh`)
- 개발 및 테스트

.skill 파일은 적절한 디렉토리 구조로 모든 스킬 파일을 포함하는 .skill 확장자를 가진 zip 파일입니다.

**로컬 전용 스킬의 경우:** 검증으로 스킬이 올바르게 구조화되었음을 확인하지만 생성된 .skill 파일은 무시할 수 있습니다.

**배포용:** 생성된 .skill 파일을 사용하여 다른 사람과 공유하세요.

선택적 출력 디렉토리:

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

검증 실패 시 스크립트는 오류를 보고하고 종료합니다. 검증 오류를 수정하고 명령을 다시 실행하세요.

### 7단계: 설치

install.sh를 실행하여 symlink를 생성하세요:

```bash
cd ~/skills-and-agents
./install.sh
```

**install.sh 동작 방식:**
- `custom/skills/`와 `custom/agents/`의 모든 스킬/에이전트를 `~/.claude/skills`, `~/.claude/agents`, `~/.agents/skills`에 symlink 생성
- `external/skills/`와 `external/agents/`의 외부 설치 스킬/에이전트도 동일하게 symlink 생성
- 기존 symlink는 자동으로 정리되고 새로운 symlink로 대체됨
- 이후 Claude Code를 재시작하면 새 스킬이 자동으로 인식됨

### 8단계: 완료 보고

스킬 이름, 트리거 조건, 간단한 설명을 제공하세요.

---

## 반복 개선

스킬을 테스트한 후 사용자는 개선을 요청할 수 있습니다. 스킬을 사용한 직후에 스킬이 어떻게 수행되었는지에 대한 신선한 컨텍스트로 이런 일이 자주 발생합니다.

**반복 워크플로우:**

1. 실제 작업에 스킬 사용
2. 어려움이나 비효율성 발견
3. SKILL.md 또는 번들 리소스를 어떻게 업데이트해야 하는지 식별
4. 변경사항을 구현하고 다시 테스트
